/*! \page usage_c_sec PANACHE Fitting C Interface

\section usage_c_df_sec Density Fitting C Interface

Include file:

\code{.c}
#include <panache/c_interface.h>
\endcode


Typically, the first (although optional) thing would be to set where
libPANACHE will print its output.

\code{.c}
panache_output(stdout);  // can be any FILE *, though
\endcode


The library (actually a DFTensor object) then must be intialized with
the basis information (using either panache_init() or panache_init2()).

\code{.cpp}
int ncenters;                   // Number of centers
C_AtomCenter * atoms;           // Atom information (length = ncenters)
int normalized;                 // Are these bases normalized or not
int * primary_nshellspercenter; // Number of primary shells on each center (length = ncenters)
C_ShellInfo * primary_shells;   // Primary shell info (length = sum of primary_nshellspercenter)
int * aux_nshellspercenter;     // Number of aux shells on each center (length = ncenters)
C_ShellInfo * aux_shells;       // Aux shell info (length = sum of aux_nshellspercenter)

char * df_dir;                  // Where to store matrices if disk is used. Can be empty (""),
                                // but not NULL. Will be overwritten if used and files exist

int nthreads;                   // Number of OpenMP threads to use


/*.... fill in the above information ...*/


int dfhandle = panache_dfinit(ncenters, atoms, normalized,
                              primary_nshellspercenter, primary_shells,
                              aux_nshellspercenter, aux_shells,
                              filename, nthreads);

/************************************************/
/* You can also use panache_dfinit2() and give  */
/*  it a file for the auxiliary basis!          */
/************************************************/

// panache makes copies of all this information, so it can be safely deleted
delete [] atoms;
delete [] primary_nshellspercenter;
delete [] primary_shells;
delete [] aux_nshellspercenter;
delete [] aux_shells;
\endcode

If needed, we need to set the C matrix (MO coefficient matrix) to be used in calculating Qmo, etc.
Also set the number of frozen and occupied orbitals.
These is not needed if you are only generating/using Qso.

\code{.c}
double * cmat;
int nmo;
int nocc, nfroz, nvir;

/*... fill in cmat & number of MOs ...*/

/* Next to last argument: 0 = normal, 1 = this is C-transpose */
panache_setcmatrix(dfhandle, cmat, nmo, 0, BSORDER_PSI4);
panache_setnocc(dfhandle, nocc, nfroz);

// PANACHE makes a copy, so it can be deleted here if needed
delete [] cmat;
\endcode

Next is to calculate the main Qso and other tensors, storing it in memory or on disk.
The second and third parameters of panache_genqtensors() are a set of flags (given in Flags.h).
The second specifies which tensors to build and the third how to store them. For example,

\code{.c}
panache_genqtensors(dfhandle, QFLAGS_QMO | QFLAGS_QOV, QSTORAGE_INMEM);
\endcode

To read the three-index tensors, we need to create a buffer where the library will place the data.
We can query for the sizes of batches/

\code{.c}
int qbatchsize;            // Batch size if reading by q

qbatchsize = panache_qbatchsize(dfhandle, QGEN_QSO);

/* In this case, qbatchsize = nso*nso if not packed, (nso*(nso+1))/2 if packed */
/* and batchsize = number of auxiliary basis functions */

double outbuffer[4*qbatchsize];  // anything > qbatchsize is ok
\endcode


To obtain the tensors, we use repeated calls to panache_getbatch. These functions
return the number of batches obtained, and is called until it returns zero.

Note that the resulting data may be in packed storage. This can be determined by
calling panache_ispacked()

\code{.c}
int curq = 0;
int nbatch = 0;
int ispacked = panache_ispacked(QGEN_QSO);

while((nbatch = panache_getqbatch(dfhandle, QGEN_QSO, outbuffer, 4*qbatchsize, curq))
{
    if(ispacked)
    {    
        // output will be nbatch blocks of size nso2 in outbuffer
        // ... do something with it!
    }
    else
    {
        // output will be nbatch blocks of size nso2 in outbuffer
        // ... do something with it!
    }
    curq += nbatch;
}
\endcode


You can also obtain the tensor "by ij", although loops will usually be set up manually.
We can get the tensor dimensions, although the calling code would know this.
For example, for MP2

\code{.c}

double e2s = 0;
double e2t = 0;

int batchsize;             // Batch size if reading by ij
batchsize = panache_batchsize(dfhandle, QGEN_QOV);

/* ndim12 will depend on packing */
int ndim1, ndim2, naux;
int ndim12 = panache_tensordimensions(dfhandle, QGEN_QOV, &naux, &ndim1, &ndim2);

double iabuff[batchsize];
double jbbuff[batchsize];
double ibbuff[batchsize];
double jabuff[batchsize];

for(int i = 0; i < nocc; i++)
for(int j = 0; j < nocc; j++)
for(int a = 0; a < nvir; a++)
for(int b = 0; b < nvir; b++)
{
    // this isn't really necessary in this case, since Qov is
    // guarenteed to not be stored packed
    int ia = panache_calcindex(dfhandle, QGEN_QOV, i, a);
    int jb = panache_calcindex(dfhandle, QGEN_QOV, j, b);
    int ib = panache_calcindex(dfhandle, QGEN_QOV, i, b);
    int ja = panache_calcindex(dfhandle, QGEN_QOV, j, a);


    // nbatch in all these cases should be 1 (since batchsize will only hold 1)
    nbatch = panache_getbatch(dfhandle, QGEN_QOV, iabuff, batchsize, ia); 
    nbatch = panache_getbatch(dfhandle, QGEN_QOV, jbbuff, batchsize, jb); 
    nbatch = panache_getbatch(dfhandle, QGEN_QOV, ibbuff, batchsize, ib); 
    nbatch = panache_getbatch(dfhandle, QGEN_QOV, jabuff, batchsize, ia);


    double iajb = 0;
    double ibja = 0;

    // loop over auxiliary index
    for(int q = 0; q < naux; i++)
    {
        iajb += iabuff[q] * jbbuff[q];        
        ibja += ibbuff[q] * jabuff[q];        
    }

    // NOTE: Remeber to take into account frozen orbitals if
    //       they are used! Ie, you probably want evec[i+nfroz] and
    //       evec[j+nfroz]
    double denom = (evec[i] + evec[j] - evec[a] - evec[b]);

    // evec contains the eigenvalues
    e2s += (iajb*iajb)/denom;
    e2t += (iajb * (iajb - ibja))/denom;
}
\endcode


When all done, cleanup this handle


\code{.c}
panache_cleanup(dfhandle);

/*... or ...*/

panache_cleanup_all(); // if you have multiple handles and are done with all of them

\endcode

That's it!



\section usage_c_ch_sec Cholesky C Interface

The Cholesky interface is almost entirely identical to the density fitting interface.
The only difference is a call to panache_chinit() rather than panache_dfinit().

\code{.c}
double delta = 1.0d-5;  // or whatever

int dfhandle = panache_chinit(ncenters, atoms, normalized,
                              primary_nshellspercenter, primary_shells,
                              delta,
                              filename, nthreads);
\endcode

The rest is completely identical to the density fitting interface.


*/
