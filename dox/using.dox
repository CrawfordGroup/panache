/////////////////////////
// USAGE               //
/////////////////////////
/*! \page usage_page Usage 

\tableofcontents

\section genusage_sec General Notes

\subsection tendim_sec Tensor Dimensions

The page uses the following definitions:

 | Term    | Description                                                             |
 |---------|-------------------------------------------------------------------------|
 | nso     | Number of \b primary basis functions (spherical or cartesian)           |
 | naux    | Number of \b auxiliary basis functions                                  |
 | nmo     | Number of molecular orbitals                                            |
 | nocc    | Number of occupied molecular orbitals                                   |
 | nvir    | Number of virtual molecular orbitals                                    |
 | q       | An auxiliary index                                                      |
 | i, j    | Generic orbital indices                                                 |
 | ij      | Combined orbital index (if packed, i*(i+1)/2+j, else i*ndim2 + j        |

The total size of a 3-index "Q" tensor is the number of auxiliary indices times
the number of combined orbital indices ("ij"). 

The number of combined orbital indices depends on the type of tensor (ie mo vs. occupied-occupied, etc)
and the packing. The following table shows the number of combined orbital indices for a given tensor
(which can be queried by DFTensor::QBatchSize)

 | Tensor | Packed Size      | Unpacked Size |
 |--------|------------------|---------------|
 | Qso    | nso*(nso+1)/2    | nso*nso       |
 | Qmo    | nmo*(nmo+1)/2    | nmo*nmo       |
 | Qoo    | nocc*(nocc+1)/2  | nocc*nocc     |
 | Qov    |                  | nocc*nvir     |
 | Qvv    | nvir*(nvir+1)/2  | nvir*nvir     |



\subsection byq_sec Storage Order

The 3-index tensors generated by DFTensor::GenQTensors() (or panache_genqtensors())
can be stored (and retrieved) either "by Q" or "by IJ". The default is by IJ, which
means the combined orbital index is the first (slowest) index. Storing and retrieving
"by Q" means that the auxiliary basis function index is the first (slowest) index.

\image html byqfig.png

A 'batch' returned from DFTensor::GetBatch() or panache_getbatch()
corresponds to a row for the "by IJ" diagram, while one returned from
DFTensor::GetQBatch() or panache_getqbatch() corresponds to a row for the
"by Q" diagram.



\subsection frozen Frozen orbitals

PANACHE supports frozen occupied orbitals. These are set with 
ThreeIndexTensor::SetNOcc(), panache_setnocc, panachef_setnocc.
In this case, orbital counting for Qmo, Qoo, and Qov start
at the first non-frozen orbital.


\section usage_sec Typical Workflow

\subsection usage_c_sec Density Fitting C Interface

Include file:

\code{.c}
#include <panache/c_interface.h>
\endcode


Typically, the first (although optional) thing would be to set where
libPANACHE will print its output.

\code{.c}
panache_output(stdout);  // can be any FILE *, though
\endcode


The library (actually a DFTensor object) then must be intialized with
the basis information (using either panache_init() or panache_init2()).

\code{.cpp}
int ncenters;                   // Number of centers
C_AtomCenter * atoms;           // Atom information (length = ncenters)
int normalized;                 // Are these bases normalized or not
int * primary_nshellspercenter; // Number of primary shells on each center (length = ncenters)
C_ShellInfo * primary_shells;   // Primary shell info (length = sum of primary_nshellspercenter)
int * aux_nshellspercenter;     // Number of aux shells on each center (length = ncenters)
C_ShellInfo * aux_shells;       // Aux shell info (length = sum of aux_nshellspercenter)

char * df_dir;                  // Where to store matrices if disk is used. Can be empty (""),
                                // but not NULL. Will be overwritten if used and files exist

int nthreads;                   // Number of OpenMP threads to use


/*.... fill in the above information ...*/


int dfhandle = panache_dfinit(ncenters, atoms, normalized,
                              primary_nshellspercenter, primary_shells,
                              aux_nshellspercenter, aux_shells,
                              filename, nthreads);

/************************************************/
/* You can also use panache_dfinit2() and give  */
/*  it a file for the auxiliary basis!          */
/************************************************/

// panache makes copies of all this information, so it can be safely deleted
delete [] atoms;
delete [] primary_nshellspercenter;
delete [] primary_shells;
delete [] aux_nshellspercenter;
delete [] aux_shells;
\endcode

If needed, we need to set the C matrix (MO coefficient matrix) to be used in calculating Qmo, etc.
This is not needed if you are only generating/using Qso

\code{.c}
double * cmat;
int nmo;

/*... fill in cmat & number of MOs ...*/

/* Next to last argument: 0 = normal, 1 = this is C-transpose */
panache_setcmatrix(dfhandle, cmat, nmo, 0, BSORDER_PSI4);

// PANACHE makes a copy, so it can be deleted here if needed
delete [] cmat;
\endcode

Next is to calculate the main Qso and other tensors, storing it in memory or on disk.
The second and third parameters of panache_genqtensors() are a set of flags (given in Flags.h).
The second specifies which tensors to build and the third how to store them. For example,

\code{.c}
panache_genqtensors(dfhandle, QFLAGS_QMO | QFLAGS_QOV, QSTORAGE_INMEM);
\endcode

To read the three-index tensors, we need to create a buffer where the library will place the data.
We can query for the sizes of batches/

\code{.c}
int qbatchsize;            // Batch size if reading by q

qbatchsize = panache_qbatchsize(dfhandle, QGEN_QSO);

/* In this case, qbatchsize = nso*nso if not packed, (nso*(nso+1))/2 if packed */
/* and batchsize = number of auxiliary basis functions */

double outbuffer[4*qbatchsize];  // anything > qbatchsize is ok
\endcode


To obtain the tensors, we use repeated calls to panache_getbatch. These functions
return the number of batches obtained, and is called until it returns zero.

Note that the resulting data may be in packed storage. This can be determined by
calling panache_ispacked()

\code{.c}
int curq = 0;
int nbatch = 0;
int ispacked = panache_ispacked(QGEN_QSO);

while((nbatch = panache_getqbatch(dfhandle, QGEN_QSO, outbuffer, 4*qbatchsize, curq))
{
    if(ispacked)
    {    
        // output will be nbatch blocks of size nso2 in outbuffer
        // ... do something with it!
    }
    else
    {
        // output will be nbatch blocks of size nso2 in outbuffer
        // ... do something with it!
    }
    curq += nbatch;
}
\endcode


You can also obtain the tensor "by ij", although loops will usually be set up manually.
We can get the tensor dimensions, although the calling code would know this.
For example, for MP2

\code{.c}

double e2s = 0;
double e2t = 0;

int batchsize;             // Batch size if reading by ij
batchsize = panache_batchsize(dfhandle, QGEN_QOV);

/* ndim12 will depend on packing */
int ndim1, ndim2, naux;
int ndim12 = panache_tensordimensions(dfhandle, QGEN_QOV, &naux, &ndim1, &ndim2);

double iabuff[batchsize];
double jbbuff[batchsize];
double ibbuff[batchsize];
double jabuff[batchsize];

for(int i = 0; i < ndim1; i++)
for(int j = 0; j <= i; j++)
for(int a = 0; a < ndim2; a++)
for(int b = 0; b <= a; b++)
{
    // this isn't really necessary in this case, since Qov is
    // guarenteed to not be stored packed
    int ia = panache_calcindex(dfhandle, QGEN_QOV, i, a);
    int jb = panache_calcindex(dfhandle, QGEN_QOV, j, b);
    int ib = panache_calcindex(dfhandle, QGEN_QOV, i, b);
    int ja = panache_calcindex(dfhandle, QGEN_QOV, j, a);


    // nbatch in all these cases should be 1 (since batchsize will only hold 1)
    nbatch = panache_getbatch(dfhandle, QGEN_QOV, iabuff, batchsize, ia); 
    nbatch = panache_getbatch(dfhandle, QGEN_QOV, jbbuff, batchsize, jb); 
    nbatch = panache_getbatch(dfhandle, QGEN_QOV, ibbuff, batchsize, ib); 
    nbatch = panache_getbatch(dfhandle, QGEN_QOV, jabuff, batchsize, ia);


    double iajb = 0;
    double ibja = 0;

    // loop over auxiliary index
    for(int q = 0; q < naux; i++)
    {
        iajb += iabuff[q] * jbbuff[q];        
        ibja += ibbuff[q] * jabuff[q];        
    }

    // NOTE: Remeber to take into account frozen orbitals if
    //       they are used! Ie, you probably want evec[i+nfroz] and
    //       evec[j+nfroz]
    double denom = (evec[i] + evec[j] - evec[a] - evec[b]);

    // evec contains the eigenvalues
    e2s += (iajb*iajb)/denom;
    e2t += (iajb * (iajb - ibja))/denom;
}
\endcode


When all done, cleanup this handle


\code{.c}
panache_cleanup(dfhandle);

/*... or ...*/

panache_cleanup_all(); // if you have multiple handles and are done with all of them

\endcode

That's it!



\subsection usage_c_ch_sec Cholesky C Interface

The Cholesky interface is almost entirely identical to the density fitting interface.
The only difference is a call to panache_chinit() rather than panache_dfinit().

\code{.c}
double delta = 1.0d-5;  // or whatever

int dfhandle = panache_chinit(ncenters, atoms, normalized,
                              primary_nshellspercenter, primary_shells,
                              delta,
                              filename, nthreads);
\endcode

The rest is completely identical to the density fitting interface.



\subsection usage_f_sec Fortran Interface

The Fortran interface is similar to the C interface, except functions
are prefixed with panachef_ rather than panache_, and functions return
information through the last parameter. The init functions are a bit more
complex, however.


\code{.f90}

! At the moment, the fortran interface allows only no printing or printing to stdout

call panachef_stdout



! see documention for panachef_init_ for definitions of the variables,
! although many should be self explanatory

! INTEGER :: dfhandle


call panachef_init(ncenters,
                   xyz, symbols, symbollen, normalized,
                   primary_nshellspercenter, primary_am, primary_is_pure,
                   primary_nprimpershell, primary_exp, primary_coef,
                   aux_nshellspercenter, aux_am, aux_is_pure,
                   aux_nprimpershell, aux_exp, aux_coef,
                   filename, filenamelen, dfhandle)


! panache makes copies of all this information, so it can be safely deallocated


! Setting number of threads
call panachef_setnthread(dfhandle, <some_number>)



! Calcuate Qso
call panachef_genqso(dfhandle, 1); // store in memory
! or
call panachef_genqso(dfhandle, 0); // store on disk


! Get dimensions, allocate buffer, give buffer to panache
! INTEGER :: nso2, naux;    ! number of primary basis functions squared, number of auxiliary basis functions
! DOUBLE PRECISION, ALLOCATABLE :: outbuffer(:)

call panachef_qsodimensions(dfhandle, naux, nso2)
call allocate(outbuffer(1:4*nso2), stat=s)
call panachef_setoutputbuffer(dfhandle, outbuffer, 4*nso2)

! Getting QSO
! INTEGER :: nbatch

nbatch = 0

call panachef_getbatch_qso(dfhandle, nbatch)
do while(nbatch > 0)
    ! output will be nbatch blocks of size nso2 in outbuffer
    ! ... do something with it!

    call panachef_getbatch_qso(dfhandle, nbatch)
end do


! Getting Qmo
! INTEGER :: nmo
! DOUBLE PRECISION :: cmat(nmo,nmo)

! If switching between Qso and Qmo
call panachef_resetbatches(dfhandle)

call panachef_setcmatrix(dfhandle, cmat, nmo, 0);  ! last argument: 0 = normal, 1 = this is C-transpose

nbatch = 0

call panachef_getbatch_qmo(dfhandle, nbatch)
do while(nbatch > 0)
    ! output will be nbatch blocks of size nso2 in outbuffer
    ! ... do something with it!

    call panachef_getbatch_qmo(dfhandle, nbatch)
end do


! cleanup time
call panachef_cleanup(dfhandle)
! or
call panachef_cleanup_all

! Can now delete outbuffer
deallocate(outbuffer)

\endcode



\subsection usage_cpp_sec C++ Interface

Typical include files:

\code{.cpp}
#include <panache/DFTensor.h>
#include <panache/Molecule.h>
#include <panache/BasisSet.h>
#include <panache/Output.h>

using namespace panache;
\endcode

Using the C++ interface involves building BasisSet, Molecule, and DFTensor
objects, but should be quite simple.

First, set the output (if desired)

\code{.cpp}
SetOutput(&cout); // or give it address of ofsream object, etc
\endcode


Then, build the molecule

\code{.cpp}
Molecule mol;

mol.add_atom( x1_cord, y1_cord, z1_cord, symbol1 );
mol.add_atom( x2_cord, y2_cord, z2_cord, symbol2 );
//...etc

\endcode


Then, a BasisSet object for the primary and auxiliary bases

\code{.cpp}
// We need a vector of vectors containing ShellInfo objects
// The first index would represent the center, and the second
// index would be a shell on that center
// ie shellmap[0][2] = third basis function, first center
std::vector<std::vector<ShellInfo> > primary_shellmap, aux_shellmap;

// fill in the information. See documentation for ShellInfo

// Now construct BasisSet objects
// These should be shared basis set objects
SharedBasisSet primary_basis(new BasisSet(mol, primary_shellmap));
SharedBasisSet aux_basis(new BasisSet(mol, aux_shellmap));


\endcode


Now construct a DFTensor object

\code{.cpp}
DFTensor dft(primary_basis, aux_basis, "/path/to/somefile.dat");
\endcode


As with the other interfaces, create a buffer and give it to DFTensor

\code{.cpp}
int naux, nso2, nso;
dft.QsoDimensions(naux, nso2);
nso = primary->nbf();

size_t buffsize = 4*nso2; // or something

std::unique_ptr<double[]> outbuf(new double[buffsize]);
dft.SetOutputBuffer(outbuf.get(), buffsize);
\endcode

Now get Qso in batches

\code{.cpp}
int n = 0;
while((n = dft.GetBatch_Qso()))
{
    // do something with it
}

\endcode

And for Qmo

\code{.cpp}

dft.ResetBatches(); // needed if switching between Qso and Qmo 


double * cmat; // your MO coefficient matrix

dft.SetCMatrix(cmat, nmo, false); // see documentation about last parameter

int n = 0;
while((n = dft.GetBatch_Qmo()))
{
    // do something with it
}

// no cleanup needed!

\endcode



\section memory_sec Memory Considerations

\todo Double check these




\subsection dftensor_memory_Sec Storage


\subsubsection memory_metric_sec Storage of the metric

   | Size             | Use                                       |
   |------------------|-------------------------------------------|
   | nso * nso        | Stores metric                             |
   | nso * nmo        | Stores C matrix                           |




\subsubsection memory_memory_sec If using storage in memory

(see DFTensor::GenQso())

   | Size             | Use                                       |
   |------------------|-------------------------------------------|
   | naux * nsotri    | Stores entire (Q\|ab) tensor              |
   | nq * nsotri      | Stores part of (Q\|ab) for unpacking      |

  

\subsubsection memory_disk_sec If using disk storage

   | Size             | Use                                                |
   |------------------|----------------------------------------------------|
   | nq  * nsotri     | Stores part of (Q\|ab) for unpacking               |
   | nq  * nso * nso  | Unpacked version of part of (Q\|ab)                |
   | nq  * nmo * nso  | Holds result of matrix multiplication QC or C(T)Q  |



\subsubsection memory_diskprefetch_sec If using disk storage with prefetching

(see \ref PANACHE_DISKPREFETCH_sec). Same as above, plus
  
   | Size             | Use                                   |
   |------------------|---------------------------------------|
   | nq  * nsotri     | Prefetched part of (Q\|ab)            |

 */
