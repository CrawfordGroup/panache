/////////////////////////
// USAGE               //
/////////////////////////
/*! \page usage_page Usage 

\tableofcontents

\section usage_sec Typical Workflow

\subsection usage_c_sec C Interface

Include file:

\code{.c}
#include <panache/c_interface.h>
\endcode


Typically, the first (although optional) thing would be to set where
libPANACHE will print its output.

\code{.c}
panache_output(stdout);  // can be any FILE *, though
\endcode


The library (actually a DFTensor object) then must be intialized with
the basis information (using either panache_init() or panache_init2()).

\code{.cpp}
int ncenters;                   // Number of centers
C_AtomCenter * atoms;           // Atom information (length = ncenters)
int normalized;                 // Are these bases normalized or not
int * primary_nshellspercenter; // Number of primary shells on each center (length = ncenters)
C_ShellInfo * primary_shells;   // Primary shell info (length = sum of primary_nshellspercenter)
int * aux_nshellspercenter;     // Number of aux shells on each center (length = ncenters)
C_ShellInfo * aux_shells;       // Aux shell info (length = sum of aux_nshellspercenter)

char * df_filename;             // Where to store matrices if disk is used. Can be empty (""),
                                // but not NULL. Will be overwritten if used and file exists


/*.... fill in the above information ...*/


int dfhandle = panache_init(ncenters, atoms, normalized,
                            primary_nshellspercenter, primary_shells,
                            aux_nshellspercenter, aux_shells,
                            filename);

// panache makes copies of all this information, so it can be safely deleted
delete [] atoms;
delete [] primary_nshellspercenter;
delete [] primary_shells;
delete [] aux_nshellspercenter;
delete [] aux_shells;
\endcode

Optionally, set the number of threads used by the this instance of the library. Default
is to use as many threads as there are cores.

\code{.c}
panache_setnthread(dfhandle, <some_number>);
\endcode


Next is to calculate the main Qso matrix, storing it in memory or on disk

\code{.c}
panache_genqso(dfhandle, 1); // store in memory

/*or*/

panache_genqso(dfhandle, 0); // store on disk
\endcode

To read Qso or Qmo, we need to set a buffer where the library will place the data.
We can query for nso (although the calling code should know this).

\code{.c}
int nso2, naux;    // number of primary basis functions squared, number of auxiliary basis functions

panache_qsodimensions(dfhandle, &naux, &nso2);

double outbuffer[4*nso2];  // usually best to be some multiple of nso2,
                           // but can be anything greater than nso2.


panache_setoutputbuffer(dfhandle, outbuffer, 4*nso2);

\endcode


If Qso is desired, we use repeated calls to panache_getbatch_qso(). This functions
returns the number of (nso*nso) sized blocks, and is called until it returns zero.

\code{.c}
int nbatch = 0;
while((nbatch = panache_getbatch_qso(dfhandle))
{
    // output will be nbatch blocks of size nso2 in outbuffer
    // ... do something with it!
}
\endcode

For Qmo, a similar procedure is used, except the MO coefficient matrix must be set first

\code{.c}
double * cmat;
int nmo;

/*... get cmat & number of MOs ...*/

panache_setcmatrix(dfhandle, cmat, nmo, 0);  // last argument: 0 = normal, 1 = this is C-transpose

// PANACHE makes a copy, so it can be deleted here if needed
delete [] cmat;
\endcode

Afterwards, do the same thing as above, but call panache_getbatch_qmo(). The only
difference is the size of the blocks will be nmo*nmo, of course.

\code{.c}
//If switching between Qso and Qmo
panache_resetbatches(dfhandle);

int nbatch = 0;
while((nbatch = panache_getbatch_qmo(dfhandle))
{
    // output will be nbatch blocks of size nmo2 in outbuffer
    // ... do something with it!
}
\endcode

When all done, cleanup this handle


\code{.c}
panache_cleanup(dfhandle);

/*... or ...*/

panache_cleanup_all(); // if you have multiple handles and are done with all of them

\endcode

That's it!


\subsection usage_f_sec Fortran Interface

The Fortran interface is similar to the C interface, except functions
are prefixed with panachef_ rather than panache_, and functions return
information through the last parameter. The init functions are a bit more
complex, however.


\code{.f90}

! At the moment, the fortran interface allows only no printing or printing to stdout

call panachef_stdout



! see documention for panachef_init_ for definitions of the variables,
! although many should be self explanatory

! INTEGER :: dfhandle


call panachef_init(ncenters,
                   xyz, symbols, symbollen, normalized,
                   primary_nshellspercenter, primary_am, primary_is_pure,
                   primary_nprimpershell, primary_exp, primary_coef,
                   aux_nshellspercenter, aux_am, aux_is_pure,
                   aux_nprimpershell, aux_exp, aux_coef,
                   filename, filenamelen, dfhandle)


! panache makes copies of all this information, so it can be safely deallocated


! Setting number of threads
call panachef_setnthread(dfhandle, <some_number>)



! Calcuate Qso
call panachef_genqso(dfhandle, 1); // store in memory
! or
call panachef_genqso(dfhandle, 0); // store on disk


! Get dimensions, allocate buffer, give buffer to panache
! INTEGER :: nso2, naux;    ! number of primary basis functions squared, number of auxiliary basis functions
! DOUBLE PRECISION, ALLOCATABLE :: outbuffer(:)

call panachef_qsodimensions(dfhandle, naux, nso2)
call allocate(outbuffer(1:4*nso2), stat=s)
call panachef_setoutputbuffer(dfhandle, outbuffer, 4*nso2)

! Getting QSO
! INTEGER :: nbatch

nbatch = 0

call panachef_getbatch_qso(dfhandle, nbatch)
do while(nbatch > 0)
    ! output will be nbatch blocks of size nso2 in outbuffer
    ! ... do something with it!

    call panachef_getbatch_qso(dfhandle, nbatch)
end do


! Getting Qmo
! INTEGER :: nmo
! DOUBLE PRECISION :: cmat(nmo,nmo)

! If switching between Qso and Qmo
call panachef_resetbatches(dfhandle)

call panachef_setcmatrix(dfhandle, cmat, nmo, 0);  ! last argument: 0 = normal, 1 = this is C-transpose

nbatch = 0

call panachef_getbatch_qmo(dfhandle, nbatch)
do while(nbatch > 0)
    ! output will be nbatch blocks of size nso2 in outbuffer
    ! ... do something with it!

    call panachef_getbatch_qmo(dfhandle, nbatch)
end do


! cleanup time
call panachef_cleanup(dfhandle)
! or
call panachef_cleanup_all

! Can now delete outbuffer
deallocate(outbuffer)

\endcode



\subsection usage_cpp_sec C++ Interface

Typical include files:

\code{.cpp}
#include <panache/DFTensor.h>
#include <panache/Molecule.h>
#include <panache/BasisSet.h>
#include <panache/Output.h>

using namespace panache;
\endcode

Using the C++ interface involves building BasisSet, Molecule, and DFTensor
objects, but should be quite simple.

First, set the output (if desired)

\code{.cpp}
SetOutput(&cout); // or give it address of ofsream object, etc
\endcode


Then, build the molecule

\code{.cpp}
Molecule mol;

mol.add_atom( x1_cord, y1_cord, z1_cord, symbol1 );
mol.add_atom( x2_cord, y2_cord, z2_cord, symbol2 );
//...etc

\endcode


Then, a BasisSet object for the primary and auxiliary bases

\code{.cpp}
// We need a vector of vectors containing ShellInfo objects
// The first index would represent the center, and the second
// index would be a shell on that center
// ie shellmap[0][2] = third basis function, first center
std::vector<std::vector<ShellInfo> > primary_shellmap, aux_shellmap;

// fill in the information. See documentation for ShellInfo

// Now construct BasisSet objects
// These should be shared basis set objects
SharedBasisSet primary_basis(new BasisSet(mol, primary_shellmap));
SharedBasisSet aux_basis(new BasisSet(mol, aux_shellmap));


\endcode


Now construct a DFTensor object

\code{.cpp}
DFTensor dft(primary_basis, aux_basis, "/path/to/somefile.dat");
\endcode


As with the other interfaces, create a buffer and give it to DFTensor

\code{.cpp}
int naux, nso2, nso;
dft.QsoDimensions(naux, nso2);
nso = primary->nbf();

size_t buffsize = 4*nso2; // or something

std::unique_ptr<double[]> outbuf(new double[buffsize]);
dft.SetOutputBuffer(outbuf.get(), buffsize);
\endcode

Now get Qso in batches

\code{.cpp}
int n = 0;
while((n = dft.GetBatch_Qso()))
{
    // do something with it
}

\endcode

And for Qmo

\code{.cpp}

dft.ResetBatches(); // needed if switching between Qso and Qmo 


double * cmat; // your MO coefficient matrix

dft.SetCMatrix(cmat, nmo, false); // see documentation about last parameter

int n = 0;
while((n = dft.GetBatch_Qmo()))
{
    // do something with it
}

// no cleanup needed!

\endcode



\section memory_sec Memory Considerations

\todo Double check these

The page uses the following definitions:

 | Term    | Description                                                             |
 |---------|-------------------------------------------------------------------------|
 | nso     | Number of \b primary basis functions (spherical or cartesian)           |
 | nmo     | Number of molecular orbitals                                            |
 | naux    | Number of \b auxiliary basis functions (spherical or cartesian)         |
 | nsotri  | Packed storage of a symmetric nso*nso matrix (nso*(nso+1))/2            |
 | nq      | Number of nso*nso or nmo*nmo matrices that can fit in the given output buffer (depending on if DFTensor::GetBatch_Qso or DFTensor::GetBatch_Qmo() is called)                                     |



\subsection dftensor_memory_Sec Storage


\subsubsection memory_metric_sec Storage of the metric

   | Size             | Use                                       |
   |------------------|-------------------------------------------|
   | nso * nso        | Stores metric                             |
   | nso * nmo        | Stores C matrix                           |




\subsubsection memory_memory_sec If using storage in memory

(see DFTensor::GenQso())

   | Size             | Use                                       |
   |------------------|-------------------------------------------|
   | naux * nsotri    | Stores entire (Q\|ab) tensor              |
   | nq * nsotri      | Stores part of (Q\|ab) for unpacking      |

  

\subsubsection memory_disk_sec If using disk storage

   | Size             | Use                                                |
   |------------------|----------------------------------------------------|
   | nq  * nsotri     | Stores part of (Q\|ab) for unpacking               |
   | nq  * nso * nso  | Unpacked version of part of (Q\|ab)                |
   | nq  * nmo * nso  | Holds result of matrix multiplication QC or C(T)Q  |



\subsubsection memory_diskprefetch_sec If using disk storage with prefetching

(see \ref PANACHE_DISKPREFETCH_sec). Same as above, plus
  
   | Size             | Use                                   |
   |------------------|---------------------------------------|
   | nq  * nsotri     | Prefetched part of (Q\|ab)            |

 */
